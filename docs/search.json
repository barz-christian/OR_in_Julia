[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OR in Julia",
    "section": "",
    "text": "In this serie we are going to solve some typical problems from operations research, mathematical optimization and modeling in Julia.\nIn order to run the code for yourself it might be good to look at setup_and_test.ipynb."
  },
  {
    "objectID": "setup_and_test.html",
    "href": "setup_and_test.html",
    "title": "2  Julia setup",
    "section": "",
    "text": "The installation of Julia is straight forward, see here.\n(optional) Install IDE Jupyter lab\n\nOpen a console and start the Julia REPL by julia [^close_julia]\n\nusing Pkg\nPkg.add(\"IJulia\")\nusing IJulia\nnotebook()\n\nFollowing the installation steps is straigthforward if you want to use miniconda.\nWith conda install it with conda install -c conda-forge jupyterlab"
  },
  {
    "objectID": "setup_and_test.html#setup-jump",
    "href": "setup_and_test.html#setup-jump",
    "title": "2  Julia setup",
    "section": "2.2 Setup Jump",
    "text": "2.2 Setup Jump\nThe following code cells install JuMP - which is a Julia package for mathematical optimization - and two solvers, which should run out of the box either on Windows or Linux systems.\n\nimport Pkg\nPkg.add(\"JuMP\")\nPkg.add(\"GLPK\")\nPkg.add(\"Ipopt\")"
  },
  {
    "objectID": "setup_and_test.html#test-installation",
    "href": "setup_and_test.html#test-installation",
    "title": "2  Julia setup",
    "section": "2.3 Test Installation",
    "text": "2.3 Test Installation\n\n# import required packages\nusing JuMP, Ipopt, GLPK\n\n\nfunction test_Ipopt(A::Matrix, b::Vector)\n           m, n = size(A)\n           model = Model(Ipopt.Optimizer)\n           set_silent(model)\n           @variable(model, x[1:n])\n           @variable(model, residuals[1:m])\n           @constraint(model, residuals == A * x - b)\n           @constraint(model, sum(x) == 1)\n           @objective(model, Min, sum(residuals.^2))\n           optimize!(model)\n           return value.(x)\nend\n\n\nA, b = rand(10, 3), rand(10);\n\nx = test_Ipopt(A, b)\n\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\n\n\n3-element Vector{Float64}:\n 0.008118583847877642\n 0.3755109757446358\n 0.6163704404074866\n\n\n\nfunction test_GLPK()\n    model = Model(GLPK.Optimizer)\n    @variable(model, x >= 0)\n    @variable(model, 0 <= y <= 3)\n    @objective(model, Min, 12x + 20y)\n    @constraint(model, c1, 6x + 8y >= 100)\n    @constraint(model, c2, 7x + 12y >= 120)\n    optimize!(model)\n    return value.(x), value.(y)\nend\ntest_GLPK()\n\n(15.000000000000005, 1.249999999999996)"
  },
  {
    "objectID": "setup_and_test.html#install-addditional-packages",
    "href": "setup_and_test.html#install-addditional-packages",
    "title": "2  Julia setup",
    "section": "2.4 Install addditional packages",
    "text": "2.4 Install addditional packages\n\nPkg.add(\"JLD2\")"
  },
  {
    "objectID": "milp/01_milp_cflp.html",
    "href": "milp/01_milp_cflp.html",
    "title": "3  Capacitated facility location problem solved by custom branching and selection rules",
    "section": "",
    "text": "We show how to solve a capacitated facility location problem (CFLP) in Julia using a MILP-Solver and how to use solver dependent callbacks to implement a custom branching and selection rule for GLPK.\nIn order to keep our example simple we choosed a classical branching rule - namely “branch on the most fractional variable” - which is often part of a MILP-Solver-implementation."
  },
  {
    "objectID": "milp/01_milp_cflp.html#problem-statement---capacitated-facility-location-problem",
    "href": "milp/01_milp_cflp.html#problem-statement---capacitated-facility-location-problem",
    "title": "3  Capacitated facility location problem solved by custom branching and selection rules",
    "section": "3.1 Problem statement - capacitated facility location problem",
    "text": "3.1 Problem statement - capacitated facility location problem\nA company must select a subset of potential facility locations to minimize total cost associated with opening facilities and servicing customers. Each costumer has a specific demand and each facility has a fixed opening costs, a specific capacity and service costs based on the distance to customers."
  },
  {
    "objectID": "milp/01_milp_cflp.html#mathematical-model",
    "href": "milp/01_milp_cflp.html#mathematical-model",
    "title": "3  Capacitated facility location problem solved by custom branching and selection rules",
    "section": "3.2 Mathematical model",
    "text": "3.2 Mathematical model\nFirst we list the the given information before we write down the model in a more mathematical way\n\n3.2.1 Sets\n\n\\(C=\\{1,\\ldots,n\\}\\) of clients\n\\(J=\\{1,\\ldots,m\\}\\) of potential facilities\n\n\n\n3.2.2 Parameter\n\n\\(c_j^f\\) fixed costs for opening facility \\(j\\)\n\\(c_{ij}^v\\) variable costs for transporting goods from facility \\(j\\) to client \\(i\\)\n\\(d_i\\) demand of client \\(i\\)\n\\(q_j\\) facility capacity\n\n\n\n3.2.3 Decision variables\n\n\\(y_i\\), binary, 1 iff facility \\(j\\) is used\n\\(x_{ij}\\), real, demand of client \\(i\\) which is served by facility \\(j\\)\n\n\n\n3.2.4 Objective\nMinimize the sum of fix and variable costs:\n\\[\n\\min \\sum_j c^f_j y_j + \\sum_{ij} c_{ij}^v x_{ij}\n\\]\n\n\n3.2.5 Constraints\n\n(c1) Each client’s demand is served:\n\n\\[\n\\sum_j x_{ij} = d_i, \\; \\forall i \\in C\n\\]\n\n(c2) A facility can only serve a client if its open:\n\n\\[\nx_{ij} \\leq d_i y_j, \\forall i\\in C, \\forall j \\in J\n\\]\n\n(c3) Capacity constraint\n\n\\[\n\\sum_i x_{ij} \\leq q_j y_j, \\forall j \\in J\n\\]\n\n3.2.5.1 MILP Formulation\n\\[\n\\begin{array}{lll}\n\\min & \\sum_j c_j^f\\cdot y_j + \\sum_{ij} c_{ij}^v \\cdot x_{ij} &\\\\\ns.t. & \\sum_j x_{ij} = d_i, & \\forall i \\in C \\\\\n     & x_{ij} \\leq d_i y_j, & \\forall i \\in C, \\forall j \\in J \\\\\n     & \\sum_i x_{ij} \\leq q_j y_j & \\forall j\\in J \\\\\n     & y_j \\in \\{ 0,1 \\}, & \\forall j\\in J\\\\\n     & x_{ij} \\in [0,d_i], & \\forall i\\in C, \\forall j\\in J\n\\end{array}\n\\]"
  },
  {
    "objectID": "milp/01_milp_cflp.html#a-simple-branching-and-selection-strategy",
    "href": "milp/01_milp_cflp.html#a-simple-branching-and-selection-strategy",
    "title": "3  Capacitated facility location problem solved by custom branching and selection rules",
    "section": "3.3 A simple branching and selection strategy",
    "text": "3.3 A simple branching and selection strategy\nFor the simplicity of the example we implement the following branching/selection strategy: 1. branch on the most fractional variable\n\\[\\arg\\max \\{|y_j - 0.5| \\forall j \\in J\\}\\]\n\nand select\n\nif \\(y_j - 0.5 < 0\\): down-branch and\nif \\(y_j - 0.5 > 0\\): up-branch.1\n\n\n\n3.3.1 Remarks on branching and selection\n\nWe remark that using the most fractional value as branching criteria is a common technique, which is also often implemented in solver. But we precisely choosed the criteria to on the one hand keep the example simple and one the other hand be able to test our implementation against existing ones.\nThere is no deeper reasoning behind the selection rule and we have choosen it just to keep the example simple.\nIn order to modify the example, you need to know the options for GLPK. They are comprehensively documented in the PDF documentation.\n\n\nusing JuMP\nimport GLPK\nimport Random\nimport MathOptInterface as MOI\n\nusing JLD2"
  },
  {
    "objectID": "milp/01_milp_cflp.html#julia-implementation",
    "href": "milp/01_milp_cflp.html#julia-implementation",
    "title": "3  Capacitated facility location problem solved by custom branching and selection rules",
    "section": "3.4 Julia implementation",
    "text": "3.4 Julia implementation\nBefore we look at an implemention of above model using Jump, let me briefly give you an overview on the full implementation\n\nA data structure holding the problem data\na function to generate random problem data (for example to test the code)\na simple output-function\na function implementing the MILP (incl. custom branch and selection strategy)\nwe modified the MILP to see when our custom branching and selection strategy was used.\n\n\n3.4.1 CFLP data structure\nWe defined a data Data Structures cflp_data to hold the problem data.\n\ninclude(\"SA_DataSturctures.jl\")\n\n\n\n3.4.2 IO\nWe wrote two functions to simply generate random problem data and to visualize the found solution.\n\ninclude(\"IO.jl\")\n\nprint_solution (generic function with 2 methods)"
  },
  {
    "objectID": "milp/01_milp_cflp.html#milp-model-implementation-with-solver-dependent-callbacks",
    "href": "milp/01_milp_cflp.html#milp-model-implementation-with-solver-dependent-callbacks",
    "title": "3  Capacitated facility location problem solved by custom branching and selection rules",
    "section": "3.5 MILP model implementation with solver dependent callbacks",
    "text": "3.5 MILP model implementation with solver dependent callbacks\n\nfunction solve_cflp(data::cflp_data)\n    \"\"\"\n    solves uncapacitated facility location problem\n    \"\"\"\n\n    # instanciate model and set optimizer\n    model = Model()\n    set_optimizer(model, GLPK.Optimizer)\n\n    # vars\n    @variable(model, y[1:data.m], Bin) #open facilities\n    @variable(model, x[1:data.n, 1:data.m], lower_bound = 0) # demand of client i served by facility j\n\n    # objective\n    fix_cost = @expression(model, sum( data.cost_fix[j] * y[j] for j in 1:data.m))\n    var_cost = @expression(model, sum( data.cost_var[i,j] * x[i,j] for i in 1:data.n for j in 1:data.m))\n    @objective(model, Min, fix_cost + var_cost)\n\n    # constraints\n    ## fulfill demand\n    @constraint(model, c1[i in 1:data.n], sum(x[i,j] for j in 1:data.m) == data.demand[i])\n    ## clients are served by open facility only\n    @constraint(model, c2[i in 1:data.n, j in 1:data.m], x[i,j] <= data.demand[i] * y[j])\n    ## obey facility capacity\n    @constraint(model, c3[j in 1:data.m], sum(x[i,j] for i in 1:data.n) <= data.capacity[j] * y[j])\n    \n    function callback_function(cb_data)\n        # determine reason for calling the callback routine\n        reason = GLPK.glp_ios_reason(cb_data.tree)\n        # ignore reason unless request for branching\n        if reason != GLPK.GLP_IBRANCH\n            return\n        end\n        y_vals = callback_value.(Ref(cb_data), y)\n        # determinine most fractional value\n        most_frac = findmin([abs(y_j - 0.5) for y_j in y_vals])[2]\n        # check if we can branch upon specifed variable\n        can_branch = GLPK.glp_ios_can_branch(cb_data.tree, most_frac)\n        if can_branch != 0 && (y_vals[most_frac] - 0.5 < 0.0)\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_DN_BRNCH)\n        elseif can_branch != 0 && (y_vals[most_frac] - 0.5 > 0.0)\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_UP_BRNCH)\n        else\n            # leave decision to solver\n            return\n        end       \n    end\n    \n    MOI.set(model, GLPK.CallbackFunction(), callback_function)\n    \n    optimize!(model)\n\n    # test before return solution\n    if !is_solved_and_feasible(model)\n        return error(\"Solver did not found an optimal solution\")\n    end\n        \n    output = Dict(\n        \"objective value\" => objective_value(model),\n        \"facilities\" => value.(y),\n        \"assignment\" => value.(x)\n    )\n    \n    return output\nend\n\nsolve_cflp (generic function with 1 method)"
  },
  {
    "objectID": "milp/01_milp_cflp.html#solve-a-simple-cflp",
    "href": "milp/01_milp_cflp.html#solve-a-simple-cflp",
    "title": "3  Capacitated facility location problem solved by custom branching and selection rules",
    "section": "3.6 Solve a simple CFLP",
    "text": "3.6 Solve a simple CFLP\nThe following problem data for a CFLP is taken from Mathematical Optimization: Solving Problems using SCIP and Python.\nIts so simple that one can easily derive an optimal solution by hand. Moreover its a good practice to test our implementation on well known instances.\n\n# use simple example data from SCIP docs\nd = [80, 270, 250, 160, 180];\nc_f = [1000.,1000.,1000.];\nc_v = [9. 6. 4.; 5. 4. 7.; 6. 3. 4.; 8. 5. 3.; 10. 8. 4.];\nq = [500,500,500]\ndata = cflp_data(c_f,c_v,q,d)\n\ncflp_data([1000.0, 1000.0, 1000.0], [9.0 6.0 4.0; 5.0 4.0 7.0; … ; 8.0 5.0 3.0; 10.0 8.0 4.0], [500, 500, 500], [80, 270, 250, 160, 180], 3, 5, 87.0, 11.0)\n\n\n\nsolution = solve_cflp(data)\nprint_solution(solution)\n\nTotal cost are:5370.000000000006\nOpen facilities:[2, 3]\nAssignment:\ncustomer   1 gets       80.000000 from facility   3\ncustomer   2 gets      270.000000 from facility   2\ncustomer   3 gets      230.000000 from facility   2\ncustomer   3 gets       20.000000 from facility   3\ncustomer   4 gets      160.000000 from facility   3\ncustomer   5 gets      180.000000 from facility   3"
  },
  {
    "objectID": "milp/01_milp_cflp.html#a-more-sophisticated-cflp",
    "href": "milp/01_milp_cflp.html#a-more-sophisticated-cflp",
    "title": "3  Capacitated facility location problem solved by custom branching and selection rules",
    "section": "3.7 A more sophisticated CFLP",
    "text": "3.7 A more sophisticated CFLP\nUnfortunately the above example was so simple, that GLPK did not used our custom branching and selection rule. Hence we look at a more sophisticated example next, which we found while testing our implementation on randomly generated data.\nTo visualize that our custom branching and selection rule was applied we added some println commands in our callback function:\n        if can_branch != 0 && (y_vals[most_frac] - 0.5 < 0.0)\n            println(\"used down-branch\")\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_DN_BRNCH)\n        elseif can_branch != 0 && (y_vals[most_frac] - 0.5 > 0.0)\n            println(\"used up-branch\")\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_UP_BRNCH)\n\nfunction solve_cflp_println(data::cflp_data)\n    \"\"\"\n    solves uncapacitated facility location problem\n    \"\"\"\n    # derive parameter from data, i.e. \n    n = length(data.demand) # number of clients n \n    m = length(data.cost_fix) # number of facilities m\n\n    # instanciate model and set optimizer\n    model = Model()\n    set_optimizer(model, GLPK.Optimizer)\n\n    # vars\n    @variable(model, y[1:m], Bin) #open facilities\n    @variable(model, x[1:n, 1:m], lower_bound = 0) # demand of client i served by facility j\n\n    # objective\n    fix_cost = @expression(model, sum( data.cost_fix[j] * y[j] for j in 1:m))\n    var_cost = @expression(model, sum( data.cost_var[i,j] * x[i,j] for i in 1:n for j in 1:m))\n    @objective(model, Min, fix_cost + var_cost)\n\n    # constraints\n    ## fulfill demand\n    @constraint(model, c1[i in 1:n], sum(x[i,j] for j in 1:m) == data.demand[i])\n    ## clients are served by open facility only\n    @constraint(model, c2[i in 1:n, j in 1:m], x[i,j] <= data.demand[i] * y[j])\n    ## obey facility capacity\n    @constraint(model, c3[j in 1:m], sum(x[i,j] for i in 1:n) <= data.capacity[j] * y[j])\n    \n    function callback_function(cb_data)\n        # determine reason for calling the callback routine\n        reason = GLPK.glp_ios_reason(cb_data.tree)\n        # ignore reason unless request for branching\n        if reason != GLPK.GLP_IBRANCH\n            return\n        end\n        y_vals = callback_value.(Ref(cb_data), y)\n        # determinine most fractional value\n        most_frac = findmin([abs(y_j - 0.5) for y_j in y_vals])[2]\n        # check if we can branch upon specifed variable\n        can_branch = GLPK.glp_ios_can_branch(cb_data.tree, most_frac)\n        if can_branch != 0 && (y_vals[most_frac] - 0.5 < 0.0)\n            println(\"used down-branch\")\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_DN_BRNCH)\n        elseif can_branch != 0 && (y_vals[most_frac] - 0.5 > 0.0)\n            println(\"used up-branch\")\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_UP_BRNCH)\n        else\n            # leave decision to solver\n            return\n        end       \n    end\n    \n    MOI.set(model, GLPK.CallbackFunction(), callback_function)\n    \n    optimize!(model)\n\n    # test before return solution\n    if !is_solved_and_feasible(model)\n        return error(\"Solver did not found an optimal solution\")\n    end\n        \n    output = Dict(\n        \"objective value\" => objective_value(model),\n        \"facilities\" => value.(y),\n        \"assignment\" => value.(x)\n    )\n    \n    return output\nend\n\nsolve_cflp_println (generic function with 1 method)\n\n\nFor simplicity we just print the first 5 customer to facility allocations.\n\nd = load(\"../data/data.jld2\")[\"data\"]\nrng_data = cflp_data(d[\"cost_fix\"], d[\"cost_var\"], d[\"capacity\"], d[\"demand\"])\nsolution = solve_cflp_println(rng_data)\nprint_solution(solution, true)\n\nused up-branch\nused up-branch\nused up-branch\nused down-branch\nused down-branch\nused up-branch\nTotal cost are:14277.130000000001\nOpen facilities:[1, 3, 5, 6, 8, 9, 10, 11, 13]\nAssignment:\ncustomer   1 gets       18.000000 from facility   9\ncustomer   2 gets       21.000000 from facility  13\ncustomer   3 gets       12.000000 from facility  11\ncustomer   4 gets       14.000000 from facility   3\ncustomer   5 gets       18.000000 from facility  13"
  },
  {
    "objectID": "milp/01_milp_cflp.html#remarks-on-code-improvements",
    "href": "milp/01_milp_cflp.html#remarks-on-code-improvements",
    "title": "3  Capacitated facility location problem solved by custom branching and selection rules",
    "section": "3.8 Remarks on code improvements",
    "text": "3.8 Remarks on code improvements\nWe like to refer to two sources to improve the performance and to improve design the design for larger models.\nIn particular it would be benefitial to create a module in the long run, but as we wanted to show how to implement solver dependet callbacks in Julia, we decided not to do it."
  },
  {
    "objectID": "sa/02_sa_cflp.html",
    "href": "sa/02_sa_cflp.html",
    "title": "4  Capacitated Facility Location Problem solved by Simulated Annealing",
    "section": "",
    "text": "We show how to solve a capacitated facility location problem (CFLP) in Julia using Simulated Annealing, which is a metaheuristic to approximate the global optimum in a large search space for an optimization problem.\nHere we used a so called combined simmulated annealing (Qin, Ni, and Shi 2012), which we explain briefly later."
  },
  {
    "objectID": "sa/02_sa_cflp.html#problem-statement",
    "href": "sa/02_sa_cflp.html#problem-statement",
    "title": "4  Capacitated Facility Location Problem solved by Simulated Annealing",
    "section": "4.1 Problem statement",
    "text": "4.1 Problem statement\nA company must select a subset of potential facility locations to minimize total cost associated with opening facilities and servicing customers. Each costumer has a specific demand and each facility has a fixed opening costs, a specific capacity and service costs based on the distance to customers. Moreover we do not want to open more than we certain number of facilities."
  },
  {
    "objectID": "sa/02_sa_cflp.html#mathematical-model-formulation",
    "href": "sa/02_sa_cflp.html#mathematical-model-formulation",
    "title": "4  Capacitated Facility Location Problem solved by Simulated Annealing",
    "section": "4.2 Mathematical model formulation",
    "text": "4.2 Mathematical model formulation\nIn order to have a more mathematical problem description we give a formulation as a mixed interger problem next:\n\n4.2.1 Sets\n\n\\(J=\\{1,\\ldots,m\\}\\) set of potential facilities\n\\(C=\\{1,\\ldots,n\\}\\) set of customers\n\n\n\n4.2.2 Parameters\n\n\\(c^f_j\\in\\mathbb{R}⁺\\) fix opening cost of facility \\(j\\)\n\\(q_j\\in\\mathbb{N}^+\\) capacity of facility \\(j\\)\n\\(d_i\\in\\mathbb{N}^+\\) demand of customer \\(i\\)\n\\(c^v_{i,j}\\in\\mathbb{R}^+\\) servicing costs from facility \\(j\\) to customer \\(i\\)\n\n\n\n4.2.3 Decision variables\n\n\\(x_{ij}\\), real, demand of customer \\(i\\) served by facility \\(j\\)\n\\(y_j\\), binary, 1 if and only if facility \\(j\\) is open\n\n\n\n4.2.4 Objective\n\\[\n\\min \\sum_j c^f_j \\cdot y_j + \\sum_{ij} c_{ij}x_{ij}\n\\]\n\n\n4.2.5 Constraints\n\n(c1) Each client’s demand is served:\n\n\\[\n\\sum_j x_{ij} = d_i, \\; \\forall i \\in C\n\\]\n\n(c2) A facility can serve a client only if its open:\n\n\\[\nx_{ij} \\leq d_i y_j, \\forall i\\in C, \\forall j \\in J\n\\]\n\n(c3) A facility can not provide more than its capacity\n\n\\[\n\\sum_i x_{ij} \\leq q_j y_j, \\forall j \\in J\n\\]\n\n(c4) There is maximal number of facilities allowed to be opened\n\n\\[\n\\sum_j y_j \\leq k,\n\\]\n\n\n4.2.6 Problem formulation as a Mixed Interger Linear Programm\n\\[\n\\begin{array}{lll}\n\\min & \\sum_j c^f_j \\cdot y_j + \\sum_{ij} c_{ij}x_{ij} &\\\\\ns.t. & \\sum_j x_{ij} = d_i & \\forall i \\in C\\\\\n     & x_{ij} \\leq d_i y_j & \\forall i\\in C, \\forall j \\in J\\\\\n     & \\sum_i x_{ij} \\leq q_j y_j & \\forall j \\in J \\\\\n     & \\sum_j y_j \\leq k & \\\\\n     & x_{ij}\\geq0 & \\\\\n     & y_j\\in\\{0,1\\}&\n\\end{array}\n\\]"
  },
  {
    "objectID": "sa/02_sa_cflp.html#implementation",
    "href": "sa/02_sa_cflp.html#implementation",
    "title": "4  Capacitated Facility Location Problem solved by Simulated Annealing",
    "section": "4.3 Implementation",
    "text": "4.3 Implementation\nFor our simulated annealing implementation we choosed a so called a combined simmulated annealing (Qin, Ni, and Shi 2012), which means we have to layers:\n\nan outer layer algorithm (OLSA), which optimizes the facility location decision\nan inner layer algorithm (ILSA), which optimizes the demand allocation decision based on the open facility decision given by the outer layer algorithm.\n\nand in each layer an simumalted annealing is used.\nBut before we look at the implementation and apply it to some examples, lets briefly give you a brief overview:\n\nData Structures\nI/O and Tests\nAdditonal functions e.g. to generate initial solutions\nCombined simmulated annealing implementation\nSolve examples\n\n\nusing Random\nusing LinearAlgebra\nusing JLD2\n\n\n# set seed for reporducibility\nRandom.seed!(123);\nRandom.TaskLocalRNG();"
  },
  {
    "objectID": "sa/02_sa_cflp.html#cflp-data-structure",
    "href": "sa/02_sa_cflp.html#cflp-data-structure",
    "title": "4  Capacitated Facility Location Problem solved by Simulated Annealing",
    "section": "4.4 CFLP data structure",
    "text": "4.4 CFLP data structure\nWe define two data Data Structures constisting of\n\ncflp_data to hold the problem data and\ncflp_solution to hold one solution, which does not necessarily need to\n\nbe optimal.\n\ninclude(\"./SA_DataSturctures.jl\")"
  },
  {
    "objectID": "sa/02_sa_cflp.html#io-and-tests-functions",
    "href": "sa/02_sa_cflp.html#io-and-tests-functions",
    "title": "4  Capacitated Facility Location Problem solved by Simulated Annealing",
    "section": "4.5 I/O and tests functions",
    "text": "4.5 I/O and tests functions\nFor simplicity of this showcase we wrote a function\n\nto randomly generate data (gen_data)\nprint the solution in a more human readable way (print_solution) and\ntest the solution for feasibility (test_cflp_solution).\n\n\ninclude(\"./IO.jl\")\ninclude(\"./Tests.jl\")\n\ntest_cflp_solution (generic function with 2 methods)"
  },
  {
    "objectID": "sa/02_sa_cflp.html#additional-functions",
    "href": "sa/02_sa_cflp.html#additional-functions",
    "title": "4  Capacitated Facility Location Problem solved by Simulated Annealing",
    "section": "4.6 Additional functions",
    "text": "4.6 Additional functions\n\ngenerate an initial solution\ngenerate a client to facility assigment based on an heuristic\ngenerate candidates for inner and outer layer simulated annealing\n\n\ninclude(\"./SA_Algorithms.jl\")\n\nSA_client_facility_assignment (generic function with 5 methods)"
  },
  {
    "objectID": "sa/02_sa_cflp.html#combined-simmulated-annealing-implementation",
    "href": "sa/02_sa_cflp.html#combined-simmulated-annealing-implementation",
    "title": "4  Capacitated Facility Location Problem solved by Simulated Annealing",
    "section": "4.7 Combined simmulated annealing implementation",
    "text": "4.7 Combined simmulated annealing implementation\nWe will implement a so called a combined simmulated annealing (Qin, Ni, and Shi 2012), which means we have to layers:\n\nan outer layer algorithm (OLSA), which optimizes the facility location decision (see SA_cflp)\nan inner layer algorithm (ILSA), which optimizes the demand allocation decision based on the open facility decision given by the outer layer algorithm (see SA_client_facility_assignment).\n\nMaybe its valuable to note that from an user point of view, there is only a “simulate annealing function” SA_cflp and the ILSA simply means running a simulated annealing to find a good solution for assigning client demand to facilities based on a fixed descision on open facilities from the OLSA.\n\n4.7.1 Outer layer algorithm - open facility decision\nIn the outer layer algorithm we explore the search space (after starting from an initial solution) by swaping the status of a randomly choosen facility (i.e. idx = rand(1:data.m) below), e.g. we swap the status of the choosen facility from close to open and vice versa. This is done by the function generate_candidate_facility below.\nAfterwards we run the inner layer algorithm to explore the search space with respect to the descision on assigning client demand to open facility, which we explain in the next section.\nOf course other strategies migth be more useful, just to give two examples:\n\nif the number of facilities is small, we could simply to an lexicographic search.\nif the number of possible facilities m is large but the number of maximal open facilities k is small, one could swap a random number of facilities simultaneously or use a rolling window with variable lenght.\n\n\nfunction generate_candidate_facility(data::cflp_data, solution::cflp_solution, k::Int)\n    \"\"\"\n    returns cflp_solution in which the decision on open facilities is randomly modified\n    the allocation of client demand to facilities is done using the heuristic assignment\n    \"\"\"\n    # generate new candidate for open facilities by swaping the value at a random index\n    candidate = copy(solution.open_facilities)\n    idx = rand(1:data.m)\n    candidate[idx] = !candidate[idx]\n    candidate_solution_heu = cflp_solution(data, candidate, heuristic_client_facility_assignment(data, candidate))\n    \n    # swap an index if generated candidate is infeasible            \n    while !test_cflp_solution(data, candidate_solution_heu, k)\n        idx = rand(1:data.m)\n        candidate[idx] = !candidate[idx]\n        candidate_solution_heu = cflp_solution(data, candidate, heuristic_client_facility_assignment(data, candidate))\n    end     \n\n    return candidate_solution_heu\nend\n\ngenerate_candidate_facility (generic function with 1 method)\n\n\n\n\n4.7.2 Inner layer algorithm - client to facility assignment\nIn the inner layer algorithm we explore the search space with respect to the assignment of client demand to facilities.\nBased on the decision on open facilities made by the outer layer algorithm the initial solution is given by an heuristic assignment, which simply said assigns to each client the cheapest available facility.\nFrom there we start shifting a random amount of client demand to a facility with free capacity:\n\nfind facility \\(j_{free}\\) with free capacity\nchoose a random client \\(i_{rand}\\)\nchoose a random facility \\(j_{rand}\\) which serves demand of client \\(i_rand\\)\nchoose a random demand (which is neither greater than assigned client demand to \\(j_{rand}\\) nor the free capacity of \\(j_{free}\\)\nmove this demand from facility \\(j_{rand}\\) to \\(j_{free}\\)\n\nThis is done in the function generate_candidate_assignment.\nWe note that this strategy in the current implementation can get stuck (see doc string of generate_candidate_assignment), which means the inner layer algorithm is running but is not exploring the search space. However this problem can be solved by checking the sufficient conditions first, before starting the inner layer algorithm. To keep the example simple we did not implemented this solution. Another option would be for example to swap a suitable demand between clients.\n\nfunction generate_candidate_assignment(data::cflp_data, solution::cflp_solution)\n    \"\"\"\n    returns a cflp_solution where the open_facilities are equal to the input, but\n    a random part of one assignment of a client demand to facilities is move to a facilitiy \n    with free capacity\n\n    N.B. In the current implementation it is possible, that the assignment matrix does not change\n    (this happens when j_free = j_rand, i.e. we take demand from the facilitiy but assign it back again)\n    In particular the SA is not exploring the search space, as its stays at the solution until the descision on open facilities changes\n    \n    In particular this happens when J = {j_rand}\n    In particular this happend with random data when k has to be choosen close to number of facilities to fulfill feasibility\n\n    In the next iteration we could implement a another decision, for example\n    \"that we simply swap a suitable demand between clients under the assumption that both have different facilities\" \n    \"\"\"\n    \n    assignment = copy(solution.assignment)\n    \n    # determine free capacity as difference of available capacity minus assigned capacity\n    free_capacity = [data.capacity[j] * solution.open_facilities[j] for j in 1:data.m]\n    free_capacity -= [sum(solution.assignment[j,:]) for j in 1:data.m]\n    \n    # get random facility with free capacity\n    j_free = rand([j for j in 1:data.m if free_capacity[j]!=0])\n    \n    # move assigned capacity randomly to j_free\n    ## but therefore we need a client and a facility and a random capacity to move first\n    i_rand = rand([i for i in 1:data.n])\n    J = [j for j in 1:data.m if solution.assignment[j, i_rand] != 0]\n    j_rand = rand(J) \n\n    cap_move = rand(1:min(free_capacity[j_free], solution.assignment[j_rand,i_rand]))\n    \n    # move capacity\n    assignment[j_free,i_rand] += cap_move\n    assignment[j_rand,i_rand] -= cap_move\n    \n    return cflp_solution(data, solution.open_facilities, assignment)\nend\n\ngenerate_candidate_assignment (generic function with 1 method)\n\n\nWe now know how to generate a new candidate assignemt with generate_candidate_assignment, so lets look at the implementation of the inner layer algorithm (SA_client_facility_assignment) next.\n\nfunction SA_client_facility_assignment(data::cflp_data, solution::cflp_solution,\n        start_temp::Float64 = 10.0, end_temp::Float64 = 1.0, alpha::Float64 = 0.5, max_iter::Int64 = 5)\n    \"\"\"\n    performs an simulated annealing to find an assignment of client demand to open facilities\n\n    returns cflp_solution with local minimal costs\n    \"\"\"\n    \n    # initial solution\n    current_solution = solution\n    best_solution = cflp_solution(data, solution.open_facilities, solution.assignment)\n\n    # iterate\n    temp = start_temp\n\n    while temp > end_temp\n        for _ in 1:max_iter\n            # generate new candidate assigning client demand to open facilities\n            candidate_solution = generate_candidate_assignment(data, current_solution)  \n\n            if  candidate_solution.cost < best_solution.cost \n                best_solution = cflp_solution(data, candidate_solution.open_facilities, \n                    candidate_solution.assignment)\n            end\n\n            if candidate_solution.cost < current_solution.cost\n                current_solution = candidate_solution\n            else\n                acceptance_prob = exp( (current_solution.cost - candidate_solution.cost) / temp )\n                if rand() < acceptance_prob\n                    current_solution = candidate_solution\n                end\n            end          \n        end        \n        temp *= alpha\n    end\n    \n    return  best_solution\n    \nend\n\nSA_client_facility_assignment (generic function with 5 methods)\n\n\nNow we have all ingredients for our outer layer algorithm SA_cflp:\n\nfunction SA_cflp(\n        data::cflp_data, k::Int64, start_temp::Float64 = 10.0, end_temp::Float64 = 1.0, alpha::Float64 = 0.5, max_iter::Int64 = 100)\n    \"\"\"\n    TBA\n    \"\"\"\n    # generate initial solution \n    current_solution = generate_initial_solution(data, k)\n    best_solution = current_solution\n\n    # iterate\n    temp = start_temp\n\n    while temp > end_temp\n        for _ in 1:max_iter\n            # generate a new decision on open facilities\n            candidate_solution_heu = generate_candidate_facility(data, current_solution, k)\n            \n            # run simulated annealing on the assignment\n            candidate_solution = SA_client_facility_assignment(data, candidate_solution_heu)\n\n            if  test_cflp_solution(data, candidate_solution, k) && candidate_solution.cost < best_solution.cost \n                best_solution = candidate_solution\n            end\n\n            if candidate_solution.cost < current_solution.cost\n                current_solution = candidate_solution\n            else\n                acceptance_prob = exp( (current_solution.cost - candidate_solution.cost) / temp )\n                if rand() < acceptance_prob\n                    current_solution = candidate_solution\n                end\n            end\n        end\n        temp *= alpha\n    end\n\n    if !test_cflp_solution(data, best_solution,k)\n        println(\"did not found a feasible solution\")\n    end\n    \n    return  best_solution\nend\n\nSA_cflp (generic function with 5 methods)"
  },
  {
    "objectID": "sa/02_sa_cflp.html#solve-examples",
    "href": "sa/02_sa_cflp.html#solve-examples",
    "title": "4  Capacitated Facility Location Problem solved by Simulated Annealing",
    "section": "4.8 Solve examples",
    "text": "4.8 Solve examples\nLets apply our implementation to some examples.\n\n4.8.1 A simple CFLP\nThe following problem data for a CFLP is taken from Mathematical Optimization: Solving Problems using SCIP and Python.\nIts so simple that one can easily derive an optimal solution by hand and we recall that one optimal solution has a total cost of ~5370.0 and uses facilities [2, 3].\n\n# data\ndemand = [80, 270, 250, 160, 180]\ncapacity = [500,500,500]\ncost_fix = [1000.,1000.,1000.]\ncost_var = [4. 6. 9.; 5. 4. 7.; 6. 3. 4.; 8. 5. 3.; 10. 8. 4.]\n\ndata = cflp_data(cost_fix, cost_var, capacity, demand);\n\n\nk = 2\nsol = SA_cflp(data, k)\nprint_solution(sol)\n\nTotal cost are:5610.0\nOpen facilities:[2, 3]\nAssignment:\ncustomer   1 gets       80.000000 from facility   2\ncustomer   2 gets      270.000000 from facility   2\ncustomer   3 gets      150.000000 from facility   2\ncustomer   3 gets      100.000000 from facility   3\ncustomer   4 gets      160.000000 from facility   3\ncustomer   5 gets      180.000000 from facility   3\n\n\n\n\n4.8.2 Example 2\nThe second example is larger and we may don’t want to solve by hand. We don’t go into details of the data and just remark, that it was randomly generated to test the implementation.\nWe did not print all the assignment of customers to facilities to increase readability , but if you are interested simply set dont_print_all to false.\n\nusing JLD2\nd = load(\"../data/data.jld2\")[\"data\"]\ndont_print_all = true\ndata = cflp_data(d[\"cost_fix\"], d[\"cost_var\"], d[\"capacity\"], d[\"demand\"])\n\nk = 9\nexample2 = SA_cflp(data, k)\nprint_solution(example2, dont_print_all)\n\nTotal cost are:14278.269999999999\nOpen facilities:[1, 3, 5, 6, 8, 9, 10, 11, 13]\nAssignment:\ncustomer   1 gets       18.000000 from facility   9\ncustomer   2 gets       21.000000 from facility  13\ncustomer   3 gets       12.000000 from facility  11\ncustomer   4 gets       14.000000 from facility   3\ncustomer   5 gets       18.000000 from facility  13\n\n\nWe recall the optimal solution of the MILP:\nTotal cost are:14277.130000000001\nOpen facilities:[1, 3, 5, 6, 8, 9, 10, 11, 13]\n\n\n4.8.3 Example 3\nWe just showcase how to randomly generate data for a CFLP and solve the corresponding CFLP by our combined simulated annealing implementation.\n\ndata = gen_data()\nk = data.m - 1\nsol = SA_cflp(data, k)\nprint_solution(sol)\n\nTotal cost are:6084.43\nOpen facilities:[2, 3, 4, 8]\nAssignment:\ncustomer   1 gets       28.000000 from facility   8\ncustomer   2 gets       15.000000 from facility   2\ncustomer   3 gets       25.000000 from facility   2\ncustomer   4 gets        7.000000 from facility   2\ncustomer   5 gets       24.000000 from facility   8\ncustomer   6 gets        5.000000 from facility   3\ncustomer   7 gets        6.000000 from facility   8\ncustomer   8 gets       21.000000 from facility   4\ncustomer   9 gets       23.000000 from facility   2\ncustomer  10 gets       23.000000 from facility   4\ncustomer  11 gets        4.000000 from facility   3\ncustomer  12 gets       26.000000 from facility   8\ncustomer  13 gets       14.000000 from facility   3\ncustomer  14 gets       13.000000 from facility   2\ncustomer  15 gets       28.000000 from facility   2\n\n\n\n\n\n\nQin, Jin, Ling-lin Ni, and Feng Shi. 2012. “Combined Simulated Annealing Algorithm for the Discrete Facility Location Problem.” The Scientific World Journal 2012 (1): 576392."
  },
  {
    "objectID": "sa/03_sa_cflp_with_heuristics.html",
    "href": "sa/03_sa_cflp_with_heuristics.html",
    "title": "5  Facility Location Problem solved by Simulated Annealing and heuristics",
    "section": "",
    "text": "We show how to solve a capacitated facility location problem (CFLP) in Julia using Simulated Annealing[^1], which is a metaheuristic to approximate global optimization in a large search space for an optimization problem.\nIn order to keep our example simple we will choose a random walk to decide which facility to open and a simple heuristic to assign facilities to customer."
  },
  {
    "objectID": "sa/03_sa_cflp_with_heuristics.html#problem-statement",
    "href": "sa/03_sa_cflp_with_heuristics.html#problem-statement",
    "title": "5  Facility Location Problem solved by Simulated Annealing and heuristics",
    "section": "5.1 Problem statement",
    "text": "5.1 Problem statement\nA company must select a subset of potential facility locations to minimize total cost associated with opening facilities and servicing customers. Each costumer has a specific demand and each facility has a fixed opening costs, a specific capacity and service costs based on the distance to customers."
  },
  {
    "objectID": "sa/03_sa_cflp_with_heuristics.html#mathematical-model-formulation",
    "href": "sa/03_sa_cflp_with_heuristics.html#mathematical-model-formulation",
    "title": "5  Facility Location Problem solved by Simulated Annealing and heuristics",
    "section": "5.2 Mathematical model formulation",
    "text": "5.2 Mathematical model formulation\nIn order to have a more mathematical problem description we give a formulation as a mixed interger problem next:\n\n5.2.1 Sets\n\n\\(J=\\{1,\\ldots,m\\}\\) set of potential facilities\n\\(C=\\{1,\\ldots,n\\}\\) set of customers\n\n\n\n5.2.2 Parameters\n\n\\(c^f_j\\in\\mathbb{R}⁺\\) fix opening cost of facility \\(j\\)\n\\(q_j\\in\\mathbb{N}^+\\) capacity of facility \\(j\\)\n\\(d_i\\in\\mathbb{N}^+\\) demand of customer \\(i\\)\n\\(c^v_{i,j}\\in\\mathbb{R}^+\\) servicing costs from facility \\(j\\) to customer \\(i\\)\n\n\n\n5.2.3 Decision variables\n\n\\(x_{ij}\\), real, demand of customer \\(i\\) served by facility \\(j\\)\n\\(y_j\\), binary, 1 if and only if facility \\(j\\) is open\n\n\n\n5.2.4 Objective\n\\[\n\\min \\sum_j c^f_j \\cdot y_j + \\sum_{ij} c_{ij}x_{ij}\n\\]\n\n\n5.2.5 Constraints\n\n(c1) Each client’s demand is served:\n\n\\[\n\\sum_j x_{ij} = d_i, \\; \\forall i \\in C\n\\]\n\n(c2) A facility can serve a client only if its open:\n\n\\[\nx_{ij} \\leq d_i y_j, \\forall i\\in C, \\forall j \\in J\n\\]\n\n(c3) A facility can not provide more than its capacity\n\n\\[\n\\sum_i x_{ij} \\leq q_j y_j, \\forall j \\in J\n\\]\n\n(c4) There is maximal number of facilities allowed to be opened\n\n\\[\n\\sum_j y_j \\leq k,\n\\]\n[1]: We remark that the Julia Optim package containts a general implementation of the Simulated Annealing algorithm.\n\n\n5.2.6 Problem formulation as a Mixed Interger Linear Programm\n\\[\n\\begin{array}{lll}\n\\min & \\sum_j c^f_j \\cdot y_j + \\sum_{ij} c_{ij}x_{ij} &\\\\\ns.t. & \\sum_j x_{ij} = d_i & \\forall i \\in C\\\\\n     & x_{ij} \\leq d_i y_j & \\forall i\\in C, \\forall j \\in J\\\\\n     & \\sum_i x_{ij} \\leq q_j y_j & \\forall j \\in J \\\\\n     & \\sum_j y_j \\leq k & \\\\\n     & x_{ij}\\geq0 & \\\\\n     & y_j\\in\\{0,1\\}&\n\\end{array}\n\\]\n\nusing Random\nusing LinearAlgebra\n\n\n# set seed for reporducibility\nRandom.seed!(1111);\nRandom.TaskLocalRNG();"
  },
  {
    "objectID": "sa/03_sa_cflp_with_heuristics.html#cflp-data-structure",
    "href": "sa/03_sa_cflp_with_heuristics.html#cflp-data-structure",
    "title": "5  Facility Location Problem solved by Simulated Annealing and heuristics",
    "section": "5.3 CFLP data structure",
    "text": "5.3 CFLP data structure"
  },
  {
    "objectID": "sa/03_sa_cflp_with_heuristics.html#load-io-adn-tests-functions",
    "href": "sa/03_sa_cflp_with_heuristics.html#load-io-adn-tests-functions",
    "title": "5  Facility Location Problem solved by Simulated Annealing and heuristics",
    "section": "5.4 load I/O adn tests functions",
    "text": "5.4 load I/O adn tests functions\nWe load some\n\ninclude(\"./SA_DataSturctures.jl\")\ninclude(\"./io.jl\")\ninclude(\"./tests.jl\")\ninclude(\"./SA_Algorithms.jl\")\n\nSA_client_facility_assignment (generic function with 5 methods)"
  },
  {
    "objectID": "sa/03_sa_cflp_with_heuristics.html#heuristics",
    "href": "sa/03_sa_cflp_with_heuristics.html#heuristics",
    "title": "5  Facility Location Problem solved by Simulated Annealing and heuristics",
    "section": "5.5 Heuristics",
    "text": "5.5 Heuristics\nBecause the search space for the assignment variable \\(x_{ij}\\) can become extremely large, we simply use a simple heuristic to compute a valid assignment of clients to facilites. This is encoded in the function client_facility_assignment.\nIn particular we choosed this design as we could replace its definition in order to perform a combined simmulated annealing (Qin, Ni, and Shi 2012), which means we have to layers:\n\nan outer layer algorithm, which optimizes the facility location decision\nan inner layer algorithm, which optimizes the demand allocation decision based on the open facility decision\n\nand in each layer an simumalted annealing is used.\n\nfunction SA_cflp_with_heuristic(\n        data::cflp_data, k::Int64, start_temp::Float64 = 10.0, end_temp::Float64 = 1.0, alpha::Float64 = 0.5, max_iter::Int64 = 100)\n    \"\"\"\n    TBA\n    \"\"\"\n    # generate initial solution \n    current_solution = generate_initial_solution(data, k)\n    best_solution = current_solution\n\n    # iterate\n    temp = start_temp\n    while temp > end_temp\n        for _ in 1:max_iter\n            # generate a new decision on open facilities\n            candidate_solution = generate_candidate_facility(data, current_solution, k)\n            \n            if  test_cflp_solution(data, candidate_solution, k) && candidate_solution.cost < best_solution.cost \n                best_solution = candidate_solution\n            end\n\n            if candidate_solution.cost < current_solution.cost\n                current_solution = candidate_solution\n            else\n                acceptance_prob = exp( (current_solution.cost - candidate_solution.cost) / temp )\n                if rand() < acceptance_prob\n                    current_solution = candidate_solution\n                end\n            end\n            \n        end\n\n\n        \n        temp *= alpha\n    end\n\n    if !test_cflp_solution(data, best_solution,k)\n        println(\"did not found a feasible solution\")\n    end\n    \n    return  best_solution\nend\n\nSA_cflp_with_heuristic (generic function with 5 methods)"
  },
  {
    "objectID": "sa/03_sa_cflp_with_heuristics.html#study-examples",
    "href": "sa/03_sa_cflp_with_heuristics.html#study-examples",
    "title": "5  Facility Location Problem solved by Simulated Annealing and heuristics",
    "section": "5.6 Study examples",
    "text": "5.6 Study examples\n\n# data\ndemand = [80, 270, 250, 160, 180]\ncapacity = [500,500,500]\ncost_fix = [1000.,1000.,1000.]\ncost_var = [4. 6. 9.; 5. 4. 7.; 6. 3. 4.; 8. 5. 3.; 10. 8. 4.]\n\ndata = cflp_data(cost_fix, cost_var, capacity, demand)\n\ncflp_data([1000.0, 1000.0, 1000.0], [4.0 6.0 9.0; 5.0 4.0 7.0; … ; 8.0 5.0 3.0; 10.0 8.0 4.0], [500, 500, 500], [80, 270, 250, 160, 180], 3, 5, 87.0, 11.0)\n\n\n\nsol = SA_cflp_with_heuristic(data, 2)\nprint_solution(sol)\n\nTotal cost are:5610.0\nOpen facilities:[2, 3]\nAssignment:\ncustomer   1 gets       80.000000 from facility   2\ncustomer   2 gets      270.000000 from facility   2\ncustomer   3 gets      150.000000 from facility   2\ncustomer   3 gets      100.000000 from facility   3\ncustomer   4 gets      160.000000 from facility   3\ncustomer   5 gets      180.000000 from facility   3\n\n\n\nusing JLD2\n\nd = load(\"../data/data.jld2\")[\"data\"]\ndont_print_all = true\ndata = cflp_data(d[\"cost_fix\"], d[\"cost_var\"], d[\"capacity\"], d[\"demand\"])\n\nk = 9\nexample2 = SA_cflp_with_heuristic(data, k)\nprint_solution(example2, dont_print_all)\n\nTotal cost are:14704.919999999998\nOpen facilities:[1, 3, 5, 7, 8, 9, 10, 11, 12]\nAssignment:\ncustomer   1 gets       18.000000 from facility   9\ncustomer   2 gets       21.000000 from facility   7\ncustomer   3 gets       12.000000 from facility  11\ncustomer   4 gets       14.000000 from facility   3\ncustomer   5 gets       18.000000 from facility   3\n\n\noptimal MILP solution\nTotal cost are:14277.130000000001 Open facilities:[1, 3, 5, 6, 8, 9, 10, 11, 13]\n\n\n\n\nQin, Jin, Ling-lin Ni, and Feng Shi. 2012. “Combined Simulated Annealing Algorithm for the Discrete Facility Location Problem.” The Scientific World Journal 2012 (1): 576392."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Qin, Jin, Ling-lin Ni, and Feng Shi. 2012. “Combined Simulated\nAnnealing Algorithm for the Discrete Facility Location Problem.”\nThe Scientific World Journal 2012 (1): 576392."
  }
]