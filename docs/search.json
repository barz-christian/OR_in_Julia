[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OR in Julia",
    "section": "",
    "text": "In this serie we are going to solve some typical problems from operations research, mathematical optimization and modeling in Julia.\n** Please remark that it is currently work in progress**"
  },
  {
    "objectID": "01_test_installation.html",
    "href": "01_test_installation.html",
    "title": "2  Julia setup",
    "section": "",
    "text": "The installation of Julia is straight forward, see here.\n(optional) Install IDE Jupyter lab\n\nOpen a console and start the Julia REPL by julia [^close_julia]\n\nusing Pkg\nPkg.add(\"IJulia\")\nusing IJulia\nnotebook()\n\nFollowing the installation steps is straigthforward if you want to use miniconda.\nWith conda install it with conda install -c conda-forge jupyterlab"
  },
  {
    "objectID": "01_test_installation.html#setup-jump",
    "href": "01_test_installation.html#setup-jump",
    "title": "2  Julia setup",
    "section": "2.2 Setup Jump",
    "text": "2.2 Setup Jump\nThe following code cells install JuMP - which is a Julia package for mathematical optimization - and two solvers, which should run out of the box either on Windows or Linux systems.\n\nimport Pkg\nPkg.add(\"JuMP\")\nPkg.add(\"GLPK\")\nPkg.add(\"Ipopt\")"
  },
  {
    "objectID": "01_test_installation.html#test-installation",
    "href": "01_test_installation.html#test-installation",
    "title": "2  Julia setup",
    "section": "2.3 Test Installation",
    "text": "2.3 Test Installation\n\n# import required packages\nusing JuMP, Ipopt, GLPK\n\n\nfunction test_Ipopt(A::Matrix, b::Vector)\n           m, n = size(A)\n           model = Model(Ipopt.Optimizer)\n           set_silent(model)\n           @variable(model, x[1:n])\n           @variable(model, residuals[1:m])\n           @constraint(model, residuals == A * x - b)\n           @constraint(model, sum(x) == 1)\n           @objective(model, Min, sum(residuals.^2))\n           optimize!(model)\n           return value.(x)\nend\n\n\nA, b = rand(10, 3), rand(10);\n\nx = test_Ipopt(A, b)\n\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\n\n\n3-element Vector{Float64}:\n 0.008118583847877642\n 0.3755109757446358\n 0.6163704404074866\n\n\n\nfunction test_GLPK()\n    model = Model(GLPK.Optimizer)\n    @variable(model, x >= 0)\n    @variable(model, 0 <= y <= 3)\n    @objective(model, Min, 12x + 20y)\n    @constraint(model, c1, 6x + 8y >= 100)\n    @constraint(model, c2, 7x + 12y >= 120)\n    optimize!(model)\n    return value.(x), value.(y)\nend\ntest_GLPK()\n\n(15.000000000000005, 1.249999999999996)"
  },
  {
    "objectID": "01_test_installation.html#install-addditional-packages",
    "href": "01_test_installation.html#install-addditional-packages",
    "title": "2  Julia setup",
    "section": "2.4 Install addditional packages",
    "text": "2.4 Install addditional packages\n\nPkg.add(\"JLD2\")"
  },
  {
    "objectID": "02_milp_cflp.html",
    "href": "02_milp_cflp.html",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "",
    "text": "We show how to solve a capacitated facility location problem (CFLP) in Julia using a standard MILP-Solver and how to use solver dependend callbacks to implement a custom branching and selection rule for GLPK.\nIn order to keep our example simple we choosed a classical branching rule - namely “branch on the most fractional variable” - which is often part of a MILP-Solver-implementation."
  },
  {
    "objectID": "02_milp_cflp.html#problem-statement---capacitated-facility-location-problem",
    "href": "02_milp_cflp.html#problem-statement---capacitated-facility-location-problem",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "3.2 Problem statement - capacitated facility location problem",
    "text": "3.2 Problem statement - capacitated facility location problem\nA company must select a subset of potential facility locations to minimize total cost associated with opening facilities and servicing customers. Each costumer has a specific demand and each facility has a fixed opening costs, a specific capacity and service costs based on the distance to customers."
  },
  {
    "objectID": "02_milp_cflp.html#mathematical-model",
    "href": "02_milp_cflp.html#mathematical-model",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "3.3 Mathematical model",
    "text": "3.3 Mathematical model\nFirst we list the the given information before we write down the model in a more mathematical way\n\n3.3.1 Sets\n\n\\(C=\\{1,\\ldots,n\\}\\) of clients\n\\(J=\\{1,\\ldots,m\\}\\) of potential facilities\n\n\n\n3.3.2 Parameter\n\n\\(c_j^f\\) fixed costs for opening facility \\(j\\)\n\\(c_{ij}^v\\) variable costs for transporting goods from facility \\(j\\) to client \\(i\\)\n\\(d_i\\) demand of client \\(i\\)\n\\(q_j\\) facility capacity\n\n\n\n3.3.3 Decision variables\n\n\\(y_i\\), binary, 1 iff facility \\(j\\) is used\n\\(x_{ij}\\), real, demand of client \\(i\\) which is served by facility \\(j\\)\n\n\n\n3.3.4 Objective\nMinimize the sum of fix and variable costs:\n\\[\n\\min \\sum_j c^f_j y_j + \\sum_{ij} c_{ij}^v x_{ij}\n\\]\n\n\n3.3.5 Constraints\n\n(c1) Each client’s demand is served:\n\n\\[\n\\sum_j x_{ij} = d_i, \\; \\forall i \\in C\n\\]\n\n(c2) A facility can only serve a client if its open:\n\n\\[\nx_{ij} \\leq d_i y_j, \\forall i\\in C, \\forall j \\in J\n\\]\n\n(c3) Capacity constraint\n\n\\[\n\\sum_i x_{ij} \\leq q_j y_j, \\forall j \\in J\n\\]\n\n3.3.5.1 MILP Formulation\n\\[\n\\begin{array}{lll}\n\\min & \\sum_j c_j^f\\cdot y_j + \\sum_{ij} c_{ij}^v \\cdot x_{ij} &\\\\\ns.t. & \\sum_j x_{ij} = d_i, & \\forall i \\in C \\\\\n     & x_{ij} \\leq d_i y_j, & \\forall i \\in C, \\forall j \\in J \\\\\n     & \\sum_i x_{ij} \\leq q_j y_j & \\forall j\\in J \\\\\n     & y_j \\in \\{ 0,1 \\}, & \\forall j\\in J\\\\\n     & x_{ij} \\in [0,d_i], & \\forall i\\in C, \\forall j\\in J\n\\end{array}\n\\]"
  },
  {
    "objectID": "02_milp_cflp.html#a-simple-branching-and-selection-strategy",
    "href": "02_milp_cflp.html#a-simple-branching-and-selection-strategy",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "3.4 A simple branching and selection strategy",
    "text": "3.4 A simple branching and selection strategy\nFor the simplicity of the example we implement the following branching/selection strategy: 1. branch on the most fractional variable\n\\[\\arg\\max \\{|y_j - 0.5| \\forall j \\in J\\}\\]\n\nand select\n\nif \\(y_j - 0.5 < 0\\): down-branch and\nif \\(y_j - 0.5 > 0\\): up-branch.1\n\n\n\n3.4.1 Remarks on branching and selection\n\nWe remark that using the most fractional value as branching criteria is a common technique, which is also often implemented in solver. But we precisely choosed the criteria to on the one hand keep the example simple and one the other hand be able to test our implementation against existing ones.\nThere is no deeper reasoning behind the selection rule and we have choosen it just to keep the example simple.\nIn order to modify the example, you need to know the options for GLPK. They are comprehensively documented in the PDF documentation."
  },
  {
    "objectID": "02_milp_cflp.html#generating-random-problem-data",
    "href": "02_milp_cflp.html#generating-random-problem-data",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "4.1 Generating random problem data",
    "text": "4.1 Generating random problem data\n\nfunction gen_data(\n        facility_number::Integer = 10,\n        client_number::Integer = 15,\n        cost_bound_fix::Real = 1000,\n        cost_bound_var::Real = 100,\n        demand_bound::Integer = 30,\n        capacity_bound::Integer = 1000\n    )\n    \"\"\"\n    returns randomly generates demand and costs for a capacitated facility location problem\n    params:\n    - ...\n    \"\"\"\n\n    # client demand\n    l = floor(Int, demand_bound/10)\n    d = rand(l:demand_bound, client_number)\n    \n    # capacities\n    l = floor(Int, capacity_bound/10)\n    q = rand(l:capacity_bound, facility_number)\n    \n    # variable costs\n    c_v = round.(rand(client_number, facility_number) * cost_bound_var, digits = 2)\n\n    # fixed costs \n    c_f = round.(rand(facility_number)* cost_bound_fix, digits = 2)\n    \n    # exclude infeaseble data, i.e. if demand > capacities than regenerate both data\n    while sum(d) > sum(q) \n        # client demand\n        l = floor(Int, demand_bound/10)\n        d = rand(l:demand_bound, client_number)\n        l = floor(Int, capacity_bound/10)\n        q = rand(l:capacity_bound, facility_number)\n    end\n    \n    return Dict(\n        \"cost_fix\" => c_f,\n        \"cost_var\" => c_v,\n        \"capacity\" => q,\n        \"demand\" => d\n    )\n    \nend\n\ngen_data (generic function with 7 methods)"
  },
  {
    "objectID": "02_milp_cflp.html#cflp-data-structure",
    "href": "02_milp_cflp.html#cflp-data-structure",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "4.2 CFLP data structure",
    "text": "4.2 CFLP data structure\n\nstruct cflpData\n    cost_fix::Vector{Float64}\n    cost_var::Matrix{Float64}\n    capacity::Vector{Int64}\n    demand::Vector{Int64} \n    \n    function cflpData(cost_fix, cost_var, capacity, demand)\n        \"\"\"\n        tests data\n        for simplicity we just test that the overall capacity is greater \n        or equal to the overall demand and check the dimensions\n        1 = capacity constraints\n        2 = equal dimensions of fix cost and capacity\n        3 = equal dimensions of var cost (column) and capacity\n        4 = equal dimensions of var cost (row) and demand\n        \"\"\"\n        \n        if sum(demand) > sum(capacity) \n            throw(DomainError(\"Demand exceeds capacity\"))\n        end\n        if length(capacity) != length(cost_fix)\n            throw(DomainError(\"Dimension capacity and fix cost dont match\"))\n        end     \n        if length(capacity) != size(cost_var)[2]\n            throw(DomainError(\"Dimension capacity and variable cost dont match\"))\n        end\n        if length(demand) != size(cost_var)[1]\n            throw(DomainError(\"Dimension demand and variable cost dont match\"))\n        end    \n        new(cost_fix, cost_var, capacity, demand)\n    end\nend"
  },
  {
    "objectID": "02_milp_cflp.html#milp-model-implementation",
    "href": "02_milp_cflp.html#milp-model-implementation",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "4.3 MILP model implementation",
    "text": "4.3 MILP model implementation\n\nfunction solve_cflp(data::cflpData)\n    \"\"\"\n    solves uncapacitated facility location problem\n    \"\"\"\n    # derive parameter from data, i.e. \n    n = length(data.demand) # number of clients n \n    m = length(data.cost_fix) # number of facilities m\n\n    # instanciate model and set optimizer\n    model = Model()\n    set_optimizer(model, GLPK.Optimizer)\n\n    # vars\n    @variable(model, y[1:m], Bin) #open facilities\n    @variable(model, x[1:n, 1:m], lower_bound = 0) # demand of client i served by facility j\n\n    # objective\n    fix_cost = @expression(model, sum( data.cost_fix[j] * y[j] for j in 1:m))\n    var_cost = @expression(model, sum( data.cost_var[i,j] * x[i,j] for i in 1:n for j in 1:m))\n    @objective(model, Min, fix_cost + var_cost)\n\n    # constraints\n    ## fulfill demand\n    @constraint(model, c1[i in 1:n], sum(x[i,j] for j in 1:m) == data.demand[i])\n    ## clients are served by open facility only\n    @constraint(model, c2[i in 1:n, j in 1:m], x[i,j] <= data.demand[i] * y[j])\n    ## obey facility capacity\n    @constraint(model, c3[j in 1:m], sum(x[i,j] for i in 1:n) <= data.capacity[j] * y[j])\n    \n    function callback_function(cb_data)\n        # determine reason for calling the callback routine\n        reason = GLPK.glp_ios_reason(cb_data.tree)\n        # ignore reason unless request for branching\n        if reason != GLPK.GLP_IBRANCH\n            return\n        end\n        y_vals = callback_value.(Ref(cb_data), y)\n        # determinine most fractional value\n        most_frac = findmin([abs(y_j - 0.5) for y_j in y_vals])[2]\n        # check if we can branch upon specifed variable\n        can_branch = GLPK.glp_ios_can_branch(cb_data.tree, most_frac)\n        if can_branch != 0 && (y_vals[most_frac] - 0.5 < 0.0)\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_DN_BRNCH)\n        elseif can_branch != 0 && (y_vals[most_frac] - 0.5 > 0.0)\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_UP_BRNCH)\n        else\n            # leave decision to solver\n            return\n        end       \n    end\n    \n    MOI.set(model, GLPK.CallbackFunction(), callback_function)\n    \n    optimize!(model)\n\n    # test before return solution\n    if !is_solved_and_feasible(model)\n        return error(\"Solver did not found an optimal solution\")\n    end\n        \n    output = Dict(\n        \"objective value\" => objective_value(model),\n        \"facilities\" => value.(y),\n        \"assignment\" => value.(x)\n    )\n    \n    return output\nend\n\nsolve_cflp (generic function with 1 method)"
  },
  {
    "objectID": "02_milp_cflp.html#simple-output-function",
    "href": "02_milp_cflp.html#simple-output-function",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "4.4 Simple Output-function",
    "text": "4.4 Simple Output-function\nWe write a simple output function next and of course there is plenty of room for improvement.\n\nusing Printf\n\nfunction print_solution(solution)\n    println(\"Total cost are:\", solution[\"objective value\"])\n    println(\"Open facilities:\", [i for i in 1:length(solution[\"facilities\"]) if solution[\"facilities\"][i] > 0])\n    println(\"Assignment:\")\n    sol = round.(solution[\"assignment\"], digits=0)\n    for i in 1:size(sol)[1] \n        for j in 1:size(sol)[2]\n            if abs(sol[i,j]) > 0.\n                s = @sprintf \"customer %3d gets %15f from facility %3d\" i round(sol[i,j], digits=1) j\n                println(s)\n            end\n        end\n    end\n    \nend\n\nprint_solution (generic function with 1 method)"
  },
  {
    "objectID": "02_milp_cflp.html#solve-a-simple-cflp",
    "href": "02_milp_cflp.html#solve-a-simple-cflp",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "4.5 Solve a simple CFLP",
    "text": "4.5 Solve a simple CFLP\nThe following problem data for a CFLP is taken from Mathematical Optimization: Solving Problems using SCIP and Python.\nIts so simple that one can easily derive an optimal solution by hand. Moreover its a good practice to test our implementation on well known instances.\n\n# use simple example data from SCIP docs\nd = [80, 270, 250, 160, 180];\nc_f = [1000.,1000.,1000.];\nc_v = [9. 6. 4.; 5. 4. 7.; 6. 3. 4.; 8. 5. 3.; 10. 8. 4.];\nq = [500,500,500]\ndata = cflpData(c_f,c_v,q,d)\n\ncflpData([1000.0, 1000.0, 1000.0], [9.0 6.0 4.0; 5.0 4.0 7.0; … ; 8.0 5.0 3.0; 10.0 8.0 4.0], [500, 500, 500], [80, 270, 250, 160, 180])\n\n\n\nsolution = solve_cflp(data)\nprint_solution(solution)\n\nTotal cost are:5370.000000000006\nOpen facilities:[2, 3]\nAssignment:\ncustomer   1 gets       80.000000 from facility   3\ncustomer   2 gets      270.000000 from facility   2\ncustomer   3 gets      230.000000 from facility   2\ncustomer   3 gets       20.000000 from facility   3\ncustomer   4 gets      160.000000 from facility   3\ncustomer   5 gets      180.000000 from facility   3"
  },
  {
    "objectID": "02_milp_cflp.html#a-more-sophisticated-cflp",
    "href": "02_milp_cflp.html#a-more-sophisticated-cflp",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "4.6 A more sophisticated CFLP",
    "text": "4.6 A more sophisticated CFLP\nUnfortunately the above example was so simple, that GLPK did not used our custom branching and selection rule. Hence we look at a more sophisticated example next, which we found while testing our implementation on randomly generated data.\nTo visualize that our custom branching and selection rule was applied we added some println commands in our callback function:\n        if can_branch != 0 && (y_vals[most_frac] - 0.5 < 0.0)\n            println(\"used down-branch\")\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_DN_BRNCH)\n        elseif can_branch != 0 && (y_vals[most_frac] - 0.5 > 0.0)\n            println(\"used up-branch\")\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_UP_BRNCH)\n\nfunction solve_cflp_println(data::cflpData)\n    \"\"\"\n    solves uncapacitated facility location problem\n    \"\"\"\n    # derive parameter from data, i.e. \n    n = length(data.demand) # number of clients n \n    m = length(data.cost_fix) # number of facilities m\n\n    # instanciate model and set optimizer\n    model = Model()\n    set_optimizer(model, GLPK.Optimizer)\n\n    # vars\n    @variable(model, y[1:m], Bin) #open facilities\n    @variable(model, x[1:n, 1:m], lower_bound = 0) # demand of client i served by facility j\n\n    # objective\n    fix_cost = @expression(model, sum( data.cost_fix[j] * y[j] for j in 1:m))\n    var_cost = @expression(model, sum( data.cost_var[i,j] * x[i,j] for i in 1:n for j in 1:m))\n    @objective(model, Min, fix_cost + var_cost)\n\n    # constraints\n    ## fulfill demand\n    @constraint(model, c1[i in 1:n], sum(x[i,j] for j in 1:m) == data.demand[i])\n    ## clients are served by open facility only\n    @constraint(model, c2[i in 1:n, j in 1:m], x[i,j] <= data.demand[i] * y[j])\n    ## obey facility capacity\n    @constraint(model, c3[j in 1:m], sum(x[i,j] for i in 1:n) <= data.capacity[j] * y[j])\n    \n    function callback_function(cb_data)\n        # determine reason for calling the callback routine\n        reason = GLPK.glp_ios_reason(cb_data.tree)\n        # ignore reason unless request for branching\n        if reason != GLPK.GLP_IBRANCH\n            return\n        end\n        y_vals = callback_value.(Ref(cb_data), y)\n        # determinine most fractional value\n        most_frac = findmin([abs(y_j - 0.5) for y_j in y_vals])[2]\n        # check if we can branch upon specifed variable\n        can_branch = GLPK.glp_ios_can_branch(cb_data.tree, most_frac)\n        if can_branch != 0 && (y_vals[most_frac] - 0.5 < 0.0)\n            println(\"used down-branch\")\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_DN_BRNCH)\n        elseif can_branch != 0 && (y_vals[most_frac] - 0.5 > 0.0)\n            println(\"used up-branch\")\n            return GLPK.glp_ios_branch_upon(cb_data.tree, most_frac, GLPK.GLP_UP_BRNCH)\n        else\n            # leave decision to solver\n            return\n        end       \n    end\n    \n    MOI.set(model, GLPK.CallbackFunction(), callback_function)\n    \n    optimize!(model)\n\n    # test before return solution\n    if !is_solved_and_feasible(model)\n        return error(\"Solver did not found an optimal solution\")\n    end\n        \n    output = Dict(\n        \"objective value\" => objective_value(model),\n        \"facilities\" => value.(y),\n        \"assignment\" => value.(x)\n    )\n    \n    return output\nend\n\nsolve_cflp_println (generic function with 1 method)\n\n\n\nd = load(\"data.jld2\")[\"data\"]\nrng_data = cflpData(d[\"cost_fix\"], d[\"cost_var\"], d[\"capacity\"], d[\"demand\"])\n\ncflpData([670.54, 426.54, 578.87, 882.52, 774.93, 637.66, 940.01, 318.03, 985.55, 314.03, 834.45, 498.44, 699.34, 754.69], [5.8 96.48 … 36.07 84.44; 33.58 45.22 … 14.96 55.39; … ; 29.48 89.31 … 67.65 77.72; 68.02 74.95 … 53.49 50.88], [234, 155, 641, 435, 779, 845, 584, 107, 237, 900, 268, 592, 476, 469], [18, 21, 12, 14, 18, 3, 28, 4, 3, 5  …  28, 10, 16, 14, 4, 27, 22, 3, 16, 4])\n\n\n\nsolution = solve_cflp_println(rng_data)\n\nused up-branch\nused up-branch\nused up-branch\nused down-branch\nused down-branch\nused up-branch\n\n\nDict{String, Any} with 3 entries:\n  \"assignment\"      => [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 21.0 0.0; … ; 0.0 0.0 … 0.…\n  \"objective value\" => 14277.1\n  \"facilities\"      => [1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, …\n\n\n\nprint_solution(solution)\n\nTotal cost are:14277.130000000001\nOpen facilities:[1, 3, 5, 6, 8, 9, 10, 11, 13]\nAssignment:\ncustomer   1 gets       18.000000 from facility   9\ncustomer   2 gets       21.000000 from facility  13\ncustomer   3 gets       12.000000 from facility  11\ncustomer   4 gets       14.000000 from facility   3\ncustomer   5 gets       18.000000 from facility  13\ncustomer   6 gets        3.000000 from facility   6\ncustomer   7 gets       28.000000 from facility  11\ncustomer   8 gets        4.000000 from facility   5\ncustomer   9 gets        3.000000 from facility   1\ncustomer  10 gets        5.000000 from facility  13\ncustomer  11 gets        7.000000 from facility   1\ncustomer  12 gets       22.000000 from facility   6\ncustomer  13 gets       28.000000 from facility   5\ncustomer  14 gets       17.000000 from facility   5\ncustomer  15 gets       24.000000 from facility   3\ncustomer  16 gets       19.000000 from facility   5\ncustomer  17 gets        3.000000 from facility   1\ncustomer  18 gets       20.000000 from facility   3\ncustomer  19 gets        5.000000 from facility   9\ncustomer  20 gets       30.000000 from facility   8\ncustomer  21 gets       23.000000 from facility   9\ncustomer  22 gets       26.000000 from facility   9\ncustomer  23 gets        4.000000 from facility   1\ncustomer  24 gets       20.000000 from facility   5\ncustomer  25 gets       18.000000 from facility  13\ncustomer  26 gets        9.000000 from facility   3\ncustomer  27 gets       27.000000 from facility   9\ncustomer  28 gets       11.000000 from facility  13\ncustomer  29 gets       17.000000 from facility  13\ncustomer  30 gets       11.000000 from facility   3\ncustomer  31 gets       16.000000 from facility   9\ncustomer  32 gets       23.000000 from facility   9\ncustomer  33 gets       12.000000 from facility   8\ncustomer  34 gets        7.000000 from facility  11\ncustomer  35 gets       21.000000 from facility  10\ncustomer  36 gets       10.000000 from facility  10\ncustomer  37 gets       23.000000 from facility   6\ncustomer  38 gets       22.000000 from facility   9\ncustomer  39 gets        9.000000 from facility   1\ncustomer  40 gets       26.000000 from facility   5\ncustomer  41 gets        9.000000 from facility   6\ncustomer  42 gets        8.000000 from facility   5\ncustomer  43 gets       26.000000 from facility  11\ncustomer  44 gets       15.000000 from facility   3\ncustomer  45 gets       18.000000 from facility  13\ncustomer  46 gets       12.000000 from facility   1\ncustomer  47 gets       23.000000 from facility   8\ncustomer  48 gets       11.000000 from facility   9\ncustomer  49 gets        7.000000 from facility  10\ncustomer  50 gets       25.000000 from facility   6\ncustomer  51 gets        3.000000 from facility   5\ncustomer  51 gets       10.000000 from facility   8\ncustomer  52 gets       28.000000 from facility   8\ncustomer  53 gets       10.000000 from facility   5\ncustomer  54 gets       16.000000 from facility   3\ncustomer  55 gets       14.000000 from facility  10\ncustomer  56 gets        4.000000 from facility   9\ncustomer  57 gets       27.000000 from facility   5\ncustomer  58 gets       22.000000 from facility   1\ncustomer  59 gets        3.000000 from facility  11\ncustomer  60 gets       16.000000 from facility   3\ncustomer  61 gets        4.000000 from facility   8"
  },
  {
    "objectID": "02_milp_cflp.html#remarks-on-code-improvements",
    "href": "02_milp_cflp.html#remarks-on-code-improvements",
    "title": "3  Solver dependent callbacks in Jump",
    "section": "4.7 Remarks on code improvements",
    "text": "4.7 Remarks on code improvements\nWe like to refer to two sources to improve the performance and to improve design the design for larger models.\nIn particular it would be benefitial to create a module in the long run, but as we wanted to show how to implement solver dependet callbacks in Julia, we decided not to do it."
  }
]